Loading with LDR Rd, =const
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The LDR Rd, =const pseduo-instruction can consturct any 32-bit numeric
constant in a single instruction. Use this pseduo-instruction to generate
constants that are out of the MOV and MVN instructions.

The LDR psedo-instruction generates the most efficient code for a specific
constant:
.	If the constant can be constructed with a MOV or MVN instruction, the 
	assembler generates the appropriate instruction.
	
. 	If the constant cannot be constructed with a MOV or MVN instruction, 
	the assembler:
	--	places the value in a literal pool(a portion of memory embedded in
		the code to hold constant values)
	--	generates an LDR instruction with a program-rative address that 
		reads the constant from the literal pool.
	For example:
		LDR	rn, [pc, #offset to the literal pool]
							; load register n with one word
							; from the address [pc + offset]
	You must ensure that there is a literal pool within range of the LDR
	instruction generated by the assembler. 
	
Placeing literal pools
~~~~~~~~~~~~~~~~~~~~~~~
	The assembler places a literal pool that at the end of each section.
	These are defined that AREA directive at the start of the following 
	section, or by the end of the assembly. The END directive at the end
	of an included file does not signal that end of a section.
	
	In large sections the default literal pool can be out of range of one
	or more LDR instructions. The offset from the pc to the constant must
	be:
	.	less that 4KB in ARM state, but can be in either direction
	.	froward and less that 1KB in Thumb state
	

	When an LDR	Rd, =const pseudo-instruction requires the constant to be 
	placed in a literal pool, the assembler:
	.	Checks if the constant is  available and addressable in any previous
		literal pools. If so, it address the existing constant.
	.	Attempts to place the constant in the next literal pool if it is 
		not already available.
	If the next literal pool is out of range, the assembler generates an
	error message. In this case you must use the LTORG directive to place
	an additional literal pool in the code. Place the LTORG dirctive after
	the failed LDR pseudo-instruction, and within 4KB(ARM) or 1KB(Thumb). 
	
	You must place literal pools where the processor does not attempt to 
	execute them  as instructions. Place them after unconditional branch
	instructions, or after the return instruction at the end of a subroutine.
	
Loading addresses with LDR Rd, = label
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The LDR Rd,= pseudo-instruction can load any 32-bit constant into a register. See 
Loading with LDR Rd, =const on page 2-27. It also accepts program-relative 
expressions such as labels, and labels with offsets.
The assembler converts an LDR r0,=label pseudo-instruction by:
? Placing the address of label in a literal pool (a portion of memory embedded in 
the code to hold constant values).
? Generating a program-relative LDR instruction that reads the address from the 
literal pool, for example:
    LDR      rn [pc, #offset to literal pool]
                        ; load register n with one word
                        ; from the address [pc + offset]
You must ensure that there is a literal pool within range. Refer to Placing literal 
pools on page 2-28 for more information.
Unlike the ADR and ADRL pseudo-instructions, you can use LDR with labels that are outside 
the current section. If the label is outside the current section, the assembler places a 
relocation directive in the object code when the source file is assembled. The relocation 
directive instructs the linker to resolve the address at link time. The address remains 
valid wherever the linker places the section containing the LDR and the literal pool.
Example 2-9 shows how this works. It is supplied as ldrlabel.s in the examples\asm 
subdirectory of the ADS. Refer to Code examples on page 2-2 for instructions on how 
to assemble, link, and execute the example.
The instructions listed in the comments are the ARM instructions that are generated by
the assembler.